# 网络

## HTTP1.1,HTTP2.0区别
* 2.0使用二进制协议，请求和响应分割为更小帧，实现多路复用。1.1基于文本。
* 2.0中，客户端向某个域名的服务器请求页面的过程中，只会创建一条TCP连接。单一的连接应该是HTTP2的主要优势，单一的连接能减少TCP握手带来的时延。支持多路复用：一个连接里，可以同时发送多个请求或回应，且无需关注顺序。2.0 将请求进行了更细粒度的分类，充分利用网络带宽，并且还能针对不同的请求进行优先级分类。1.1中，只能串行请求，效率低。
* 头部信息压缩，1.1每次请求都会带上所有信息，比如Cookie。2.0对头部信息gzip压缩
* 2.0支持服务器推送资源，仅限静态资源。

### 1.1 HTTP队头阻塞
* 默认情况下，浏览器对同一域名下的并发连接数有限制（通常为6-8个），这意味着浏览器同一时间最多只能与服务器建立6-8个连接。同时，在同一连接中，请求和响应是按照顺序处理的。
* HTTP队头堵塞是指在同一域名下浏览器的连接数有限制，并且请求要在连接内按顺序处理。

### TCP 队头阻塞
* TCP协议为了保证数据包的有序传输，如果一个数据包在丢失损坏后，TCP`接受端`会要求重新发送该数据包，直到被正确接收为止。

## HTTP和HTTPS区别
* HTTPS需要CA证书，HTTP不需要
* HTTP是明文传输，不安全。而HTTPS基于SSL进行加密，相对安全。
* HTTP端口为80，HTTPS端口443 

## HTTP keep-live
* 即长连接。
* 1.0中，请求完成后，立刻断开，是短连接。在请求头中，加上`Connection:keep-live`，来建立长连接。
* 1.1中，默认开启长连接。
* 2.0中，允许一个连接上处理多个请求和响应，取代了`keep-live`

## 三次握手
* ![](https://cdn.jsdelivr.net/gh/hutaoer/images/20230918151745.png)
* 指建立一个TCP连接时，需要客户端和服务器总共发送3个包，主要作用是为了确认双方接受和发放能力是否正常。
* 第一次握手 客户端给服务器发送一个TCP报文【向服务器请求连接】
  - SYN = 1
  - seq = x
  - 客户端 SYN-SEND 状态
* 第二次握手 服务器接收到 SYN 报文后，回复浏览器 【同意连接】
  - SYN = 1
  - ACK = 1
  - seq = y
  - ack = x + 1
  - 服务端进入SYN-REVD状态
* 第三次握手 浏览器收到报文后回复服务器 【收到回复】
  - ACK = 1
  - seq = x + 1
  - ack = y + 1
  - 客户端、服务器同时进入 ESTABLISHED，建立连接，传输数据。
* 那为什么要三次握手呢？两次不行吗？ 为了确认双方的接收能力和发送能力都正常。服务端在发送完`SYN`报文后，客户端需要回复一个`ACK`告诉服务的确认有效。

## 四次挥手
* ![](https://cdn.jsdelivr.net/gh/hutaoer/images/20230918151803.png)
* 客户端、服务端都处于建立建立状态
* 第一次挥手 向服务器发送报文，
  - 浏览器进入 FIN-WAIT-1 半关闭阶段。
* 第二次挥手 `服务器`收到报文后，知道浏览器要断开链接，开始处理内部操作。
  - 服务器进入 COLSE-WAIT 处理阶段
  - 浏览器进入 FIN-WAIT-2 阶段 等待服务器处理
* 第三次挥手 `服务器`处理完毕 回复`浏览器`
  - 服务器进入 LAST-ACK 阶段 等待浏览器确认收到
* 第四次挥手 浏览器收到服务器报文 回复服务器
  - 浏览器进入 TIME-WAIT 阶段，此时TCP未释放掉，等待 2MSL(毫秒)，等待服务器收到自己的报文，然后进入 COLSE 阶段
* 为什么是四次 客户端发送FIN报文后，表示客户端当前没有数据需要处理，而`不代表服务端没有数据需要处理`。此时需要服务端回复ACK确认收到报文后，开始处理内部数据。当内部数据处理完后，再回复FIN可以关闭连接。

## 浏览器输入URL发生了什么
* URL解析，判断URL是否符合规范
* 浏览器判断缓存，判断请求都资源是否有缓存，如果有就不需要向服务器发送新的请求，如「强缓存、协商缓存」
* DNS解析，获取目标服务器ip
* 建立TCP连接（三次握手）
* 发送HTTP请求
* 服务器处理，返回数据
* 浏览器解析渲染页面，「浏览器渲染过程」
* TCP连接关闭（四次挥手）

## HTTPS协议
* HTTPS在HTTP层和tcp层中间加了一个SSL/TLS安全层，进行加密，避免了HTTP协议存在的信息窃听，信息劫持等风险。
* 三个算法：
  - 对称加密： 用一个密钥加密数据，加密后也可以对其解密。存在安全风险，容易被劫持
  - 非对称加密：一个公钥一个私，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。如果公钥是一开始通过明文传输给浏览器的，也会造成劫持，用公钥解密数据。
  - CA证书：向机构申请一份`CA证书`，里面包含网站信息和公钥A，服务端证书传给浏览器，浏览器验证证书，拿到公钥A

## HTTP状态码
* 2xx，正常
* 3XX
  - 301永久重定向
  - 302临时重定向
  - 304协商缓存
* 4XX
  - 400: 服务器无法理解请求格式，需要修改请求内容后再次发起请求（入参格式问题）
  - 401: 请求未授权
  - 403: 禁止访问
  - 404: 服务器上无法找到请求资源
* 5XX：服务器错误

## DNS完整查询过程
* 浏览器缓存查询是否有对应IP，没有的话
* 发送请求到本地DNS服务器，本地域名服务器缓存中如果有，直接返回，没有就向上级服务器迭代查询。
* 本地DNS服务器向`根域名服务器`发送请求，根域名服务器会返回一个`顶级域名服务器地址`。
* 本地DNS服务器向`顶级域名服务器`发送请求，顶级域名服务器查询自己的缓存，如果有就返回，如果没有返回`下一级权威域名服务器地址`。
* 本地DNS服务器向`权威域名服务器`发送请求，服务器返回域名对应的ip
* 本地DNS服务器将返回结果保存，方便下次查询。
* 本地DNS服务器将IP返回给浏览器

## OSI七层模型
* 物理层：通过物理媒介（光纤，电缆）传输数据
* 数据链路层：介质访问和链路管理
* 网络层：IP选址和路由选择
* 传输层：管理端到端的连接
* 会话层：管理会话
* 表示层：数据格式转换和加密
* 应用层：应用程序服务

## TCP/IP五层协议
* 物理层：
* 数据链路层：
* 网络层：
* 传输层：TCP/UDP
* 应用层：
* ![](https://cdn.jsdelivr.net/gh/hutaoer/images/20230918151718.png)

## TCP和UDP协议的区别和应用场景
* TCP
  - 点对点连接，可靠，全双工通信
  - 应用：HTTP文本传输，电子邮件，FTP，SSH远程登录，HTTPS。
* UDP
  - 不需要建立三次握手，支持1对1，一对多，不可靠
  - 应用：DNS查询，语音通话，同步计算机时间。

### UDP为什么不可靠
* 传输数据之前不需要先建立连接；不需要确认；不跟踪连接

## 对 WebSocket 的理解
* WebSocket 是一种在单个`TCP 连接`上实现`全双工通信`的网络协议，与传统的 HTTP 协议不同，HTTP是基于请求-响应模式，即客户端发送请求，服务器返回响应，然后连接关闭。而 `WebSocket` 允许客户端和服务器之间保持`持久性的连接`，双方可以随时互相发送数据，而不需要每次通信都建立新的连接。
