# 模块化

## 模块化的发展是怎样的
* CommonJS（nodejs）
* AMD
* CMD
* ESM

## ES6与CommonJS中的模块处理
* CommonJS：使用require来引入其他模块的代码，使用module.exports来引出。导出的函数是原函数的一次拷贝，修改函数的属性值不会对其他require的地方造成影响。
* CommonJS 模块输出的是一个值的拷贝。ES6 模块输出的是值的引用。
* CommonJS模块是运行时加载，ES6模块是编译时输出接口。
* export出来的值必须要有一个命名，否则从语法层次便会报错。

## CommonJS模块的加载原理
* CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。
* CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
* 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。
* 在循环加载过程中，一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

## ES6模块的循环加载
* ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只`生成一个引用`。等到真的需要用到时，再到模块里面去取值。
* ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，以及变量总是绑定其所在的模块。
* 所以运行过程中，模块的值是可能变化的，因为只是一个引用。

## 如何处理循环引入模块
* 这导致ES6处理"循环加载"与CommonJS有本质的不同。ES6根本不会关心是否发生了"循环加载"，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
* 只要引用是存在的，代码就能执行。
